<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WiFi Network Scanner</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Monaco', 'Courier New', monospace;
            background: #000;
            color: #0f0;
            overflow: hidden;
        }
        .header {
            position: fixed; top: 0; left: 0; right: 0;
            background: rgba(0, 15, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            z-index: 1000;
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #0f0;
            text-shadow: 0 0 5px #0f0;
        }
        .title { font-size: 24px; font-weight: bold; }
        .controls { display: flex; gap: 15px; align-items: center; }
        select, button {
            padding: 8px 12px;
            border: 1px solid #0f0;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
            color: #0f0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        select:hover, button:hover { background: #0f0; color: #000; }
        button { background: #050; }
        button:hover { background: #0f0; color: #000; }
        button.stop { background: #500; }
        button.stop:hover { background: #f00; color: #000; }
        .status { font-size: 14px; opacity: 0.8; }
        .stats {
            position: fixed; top: 80px; right: 20px;
            background: rgba(0, 15, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px; border-radius: 10px;
            z-index: 999; min-width: 200px;
            border: 1px solid #0f0;
        }
        .stats h3 { margin-bottom: 10px; font-size: 16px; text-shadow: 0 0 5px #0f0; }
        .stat-item { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px; }
        .network-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        .node { 
            cursor: pointer; 
            transition: opacity 2.0s ease-in-out;
        }
        .node circle {
            transition: r 0.5s ease; /* Smooth radius transition */
        }
        .node.ghost { 
            opacity: 0.15;
        }
        .node.ap circle { fill: #0f0; stroke: #fff; }
        .node.client circle { fill: #0a0; stroke: #0c0; }
        .node.multicast circle { fill: #050; stroke: #080; }
        .node text {
            pointer-events: none;
            font-family: 'Monaco', 'Courier New', monospace;
            fill: #0f0;
            text-shadow: 0 0 5px #0f0, 0 0 10px #0f0;
        }
        .node.ap text {
            fill: #fff;
            font-weight: bold;
        }
        .link { stroke: #0f0; stroke-opacity: 0.6; stroke-linecap: round; fill: none; }
        .legend {
            position: fixed; bottom: 20px; left: 20px;
            background: rgba(0, 15, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px; border-radius: 10px;
            z-index: 999;
            border: 1px solid #0f0;
        }
        .legend h3 { margin-bottom: 10px; font-size: 16px; text-shadow: 0 0 5px #0f0; }
        .legend-item { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; font-size: 14px; }
        .legend-color { width: 20px; height: 20px; border-radius: 50%; border: 2px solid #0f0; }
        .tooltip {
            position: absolute; text-align: left;
            width: auto; height: auto;
            padding: 8px; font: 12px 'Monaco', 'Courier New', monospace;
            background: #000; border: 1px solid #0f0;
            border-radius: 8px; pointer-events: none;
            opacity: 0; color: #0f0;
        }
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: #0f0; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #0f0; }
        input:checked + .slider:before { background-color: #000; transform: translateX(26px); }
        .toggle-label, .slider-label { display: flex; align-items: center; gap: 10px; }

        input[type=range] {
            height: 24px;
            -webkit-appearance: none;
            margin: 10px 0;
            width: 100%;
            background: transparent;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 5px;
            cursor: pointer;
            background: #050;
            border-radius: 5px;
            border: 1px solid #0f0;
        }
        input[type=range]::-webkit-slider-thumb {
            border: 1px solid #0f0;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #0f0;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -7px;
        }
        input[type=range]::-moz-range-track {
            width: 100%;
            height: 5px;
            cursor: pointer;
            background: #050;
            border-radius: 5px;
            border: 1px solid #0f0;
        }
        input[type=range]::-moz-range-thumb {
            border: 1px solid #0f0;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #0f0;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">WiFi Network Scanner</div>
        <div class="controls">
            <div class="slider-label">
                <span>Persistence: <span id="persistenceValue">1</span> min</span>
                <input type="range" min="1" max="60" value="1" id="persistenceSlider">
            </div>
            <div class="toggle-label">
                <span>Ghost Mode</span>
                <label class="switch">
                    <input type="checkbox" id="ghostModeToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="toggle-label">
                <span>Filter Multicast</span>
                <label class="switch">
                    <input type="checkbox" id="multicastFilterToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <select id="interfaceSelect"><option value="">Select Interface</option></select>
            <button id="startBtn">Start Scan</button>
            <button id="stopBtn" class="stop" style="display: none;">Stop Scan</button>
        </div>
        <div class="status" id="status">Ready</div>
    </div>
    <div class="stats">
        <h3>Network Statistics</h3>
        <div class="stat-item"><span>Access Points:</span><span id="apCount">0</span></div>
        <div class="stat-item"><span>Clients:</span><span id="clientCount">0</span></div>
        <div class="stat-item"><span>Connections:</span><span id="connectionCount">0</span></div>
        <div class="stat-item"><span>Total Packets:</span><span id="packetCount">0</span></div>
    </div>
    <div class="legend">
        <h3>Legend</h3>
        <div class="legend-item"><div class="legend-color" style="background: #0f0;"></div><span>Access Points</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #0a0;"></div><span>Clients</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #050;"></div><span>Multicast/Broadcast</span></div>
    </div>
    <div class="tooltip"></div>
    <svg class="network-canvas" id="networkCanvas"></svg>

    <script>
        let socket;
        let simulation;
        let lastData = null;
        let isolatedNodeId = null;
        const width = window.innerWidth;
        const height = window.innerHeight;
        const nodeMap = new Map();

        const svg = d3.select('#networkCanvas').attr('width', width).attr('height', height);
        svg.on("click", () => {
            if (isolatedNodeId) {
                isolatedNodeId = null;
                updateNetwork(lastData);
            }
        });

        const g = svg.append('g');
        let link = g.append("g").attr("stroke-opacity", 0.6).selectAll("path");
        let node = g.append("g").selectAll("g");

        const tooltip = d3.select(".tooltip");

        const zoom = d3.zoom().scaleExtent([0.1, 8]).on('zoom', (event) => {
            g.attr('transform', event.transform);
            const k = event.transform.k;
            g.selectAll('.node text').attr('font-size', 14 / k);
            g.selectAll('.node circle').attr('stroke-width', 2 / k);
        });

        svg.call(zoom);

        function ticked() {
            link.attr("d", d => {
                if (d.source.x === undefined || d.target.x === undefined) return null;
                const dx = d.target.x - d.source.x;
                const dy = d.target.y - d.source.y;
                const dr = Math.sqrt(dx * dx + dy * dy);
                return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
            });
            node.attr("transform", d => `translate(${d.x},${d.y})`);
        }

        // --- NEW: Function to scale signal strength to radius ---
        const radiusScale = d3.scaleLinear()
            .domain([-90, -30]) // Typical dBm range
            .range([15, 40])     // Pixel radius range
            .clamp(true);

        simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id).distance(150).strength(1))
            .force("charge", d3.forceManyBody().strength(-1800))
            .force("center", d3.forceCenter(width / 2, height / 2).strength(0.8))
            // --- MODIFIED: Collision force now uses the dynamic radius ---
            .force("collide", d3.forceCollide().radius(d => radiusScale(d.signal_strength || -90) + 5).strength(1))
            .force("x", d3.forceX(width / 2).strength(0.1))
            .force("y", d3.forceY(height / 2).strength(0.1))
            .on("tick", ticked);

        function updateNetwork(data) {
            if (!data) return;
            lastData = data;

            const allLinks = data.connections.map(d => ({...d, source: d.ap_bssid, target: d.client_mac}));

            document.getElementById('apCount').textContent = data.access_points.length;
            document.getElementById('clientCount').textContent = data.clients.filter(c => c.type !== 'multicast').length;
            document.getElementById('connectionCount').textContent = allLinks.length;
            document.getElementById('packetCount').textContent = allLinks.reduce((sum, conn) => sum + conn.packet_count, 0);

            const allNodesData = data.access_points.map(ap => {
                return {...ap, id: ap.bssid, type: 'ap', displayLabel: `${ap.ssid || 'Unknown'}\n${ap.bssid}`};
            }).concat(data.clients.map(c => {
                let label = (c.label || 'Client') + `\n${c.mac}`;
                return {...c, id: c.mac, type: c.type || 'client', displayLabel: label};
            }));

            allNodesData.forEach(n => {
                const existingNode = nodeMap.get(n.id);
                if (existingNode) {
                    const { fx, fy, probed_ssids } = existingNode;
                    Object.assign(existingNode, n);
                    existingNode.fx = fx;
                    existingNode.fy = fy;
                    if(n.probed_ssids) {
                        existingNode.probed_ssids = new Set([...(probed_ssids || []), ...n.probed_ssids]);
                    }
                } else {
                    if(n.probed_ssids) n.probed_ssids = new Set(n.probed_ssids);
                    nodeMap.set(n.id, n);
                }
            });

            let visibleNodes = [];
            let visibleLinks = allLinks;
            
            const allActiveNodeIds = new Set(allNodesData.map(n => n.id));
            const allActiveNodes = Array.from(nodeMap.values()).filter(n => allActiveNodeIds.has(n.id));

            if (isolatedNodeId) {
                const connectedClientIds = new Set();
                visibleLinks = allLinks.filter(conn => {
                    if (conn.source === isolatedNodeId) {
                        connectedClientIds.add(conn.target);
                        return true;
                    }
                    return false;
                });
                const visibleNodeIds = new Set([isolatedNodeId, ...connectedClientIds]);
                visibleNodes = allActiveNodes.filter(n => visibleNodeIds.has(n.id));
                
                simulation.force("center").strength(0);
                simulation.force("x").strength(0);
                simulation.force("y").strength(0);

            } else {
                visibleNodes = allActiveNodes;
                simulation.force("center").strength(0.8);
                simulation.force("x").strength(0.1);
                simulation.force("y").strength(0.1);
            }
            
            node = node.data(visibleNodes, d => d.id)
                .join(
                    enter => {
                        const g = enter.append("g");
                        // --- MODIFIED: Set initial radius based on signal strength ---
                        g.append("circle").attr("r", d => radiusScale(d.signal_strength || -90));
                        g.append("text")
                         .attr("y", -35)
                         .attr("text-anchor", "middle")
                         .attr("font-size", "14")
                         .selectAll("tspan")
                         .data(d => d.displayLabel.split('\n'))
                         .enter().append("tspan")
                         .attr("x", 0)
                         .attr("dy", (d, i) => i > 0 ? "1.2em" : 0)
                         .text(d => d);
                        return g;
                    },
                    update => {
                        // --- MODIFIED: Update radius on existing nodes ---
                        update.select("circle").attr("r", d => radiusScale(d.signal_strength || -90));
                        update.select("text").selectAll("tspan").remove();
                        update.select("text").selectAll("tspan")
                         .data(d => d.displayLabel.split('\n'))
                         .enter().append("tspan")
                         .attr("x", 0)
                         .attr("dy", (d, i) => i > 0 ? "1.2em" : 0)
                         .text(d => d);
                        return update;
                    }
                )
                .attr("class", d => `node ${d.type} ${d.state === 'ghost' ? 'ghost' : ''}`)
                .call(drag(simulation))
                .on("mouseover", (event, d) => {
                    tooltip.transition().duration(200).style("opacity", .9);
                    let tooltip_html = `<strong>${d.label || d.type.charAt(0).toUpperCase() + d.type.slice(1)}</strong><br/>`;
                    if (d.type === 'ap' || d.type === 'client') { // Show signal for APs and Clients
                        tooltip_html += `Signal: ${d.signal_strength || 'N/A'} dBm<br/>`;
                    }
                    if (d.type === 'ap') {
                        tooltip_html += `SSID: ${d.ssid}<br/>BSSID: ${d.bssid}<br/>Channel: ${d.channel}`;
                    } else {
                        tooltip_html += `MAC: ${d.mac}`;
                        const probed = Array.from(d.probed_ssids || []);
                        if (probed.length > 0) {
                            tooltip_html += `<br/><br/><strong>Probing for:</strong><br/>- ${probed.join('<br/>- ')}`;
                        }
                    }
                    tooltip.html(tooltip_html)
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY - 40) + "px"); // Changed from -28 to -40 to place tooltip on top
                })
                .on("mouseout", () => {
                    tooltip.transition().duration(500).style("opacity", 0);
                });

            node.on("click", (event, d) => {
                event.stopPropagation();
                if (d.type === 'ap') {
                    isolatedNodeId = (isolatedNodeId === d.id) ? null : d.id;
                    updateNetwork(lastData);
                }
            });

            node.on("dblclick", (event, d) => {
                event.stopPropagation();
                d.fx = null;
                d.fy = null;
            });
            
            link = link.data(visibleLinks, d => `${d.source}-${d.target}`).join("path")
                .attr("class", "link")
                .attr("stroke-width", d => Math.min(12, Math.max(1.5, d.thickness / 1.5)));

            simulation.nodes(visibleNodes);
            simulation.force("link").links(visibleLinks);
            simulation.alpha(0.3).restart();
        }

        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
            }
            return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }

        async function loadInterfaces() {
            try {
                const response = await fetch('/api/interfaces');
                const data = await response.json();
                const select = document.getElementById('interfaceSelect');
                select.innerHTML = '<option value="">Select Interface</option>';
                data.interfaces.forEach(iface => {
                    const option = document.createElement('option');
                    option.value = iface; option.textContent = iface;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading interfaces:', error);
            }
        }

        async function startScan() {
            const selectedInterface = document.getElementById('interfaceSelect').value;
            if (!selectedInterface) return alert('Please select a WiFi interface');

            await fetch('/api/start_scan', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ interface: selectedInterface })
            });
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'block';
        }

        async function stopScan() {
            await fetch('/api/stop_scan', { method: 'POST' });
            document.getElementById('startBtn').style.display = 'block';
            document.getElementById('stopBtn').style.display = 'none';
            nodeMap.clear();
            isolatedNodeId = null;
            lastData = null;
            updateNetwork({access_points:[], clients:[], connections:[]});
        }

        function updateSettings() {
            const ghostMode = document.getElementById('ghostModeToggle').checked;
            const filterMulticast = document.getElementById('multicastFilterToggle').checked;
            const persistence = parseInt(document.getElementById('persistenceSlider').value);
            socket.emit('update_settings', { ghostMode, filterMulticast, persistence });
        }

        document.addEventListener('DOMContentLoaded', () => {
            loadInterfaces();
            socket = io();
            socket.on('network_update', updateNetwork);
            socket.on('status', data => document.getElementById('status').textContent = data.message);
            document.getElementById('startBtn').addEventListener('click', startScan);
            document.getElementById('stopBtn').addEventListener('click', stopScan);
            document.getElementById('ghostModeToggle').addEventListener('change', updateSettings);
            document.getElementById('multicastFilterToggle').addEventListener('change', updateSettings);

            const persistenceSlider = document.getElementById('persistenceSlider');
            const persistenceValue = document.getElementById('persistenceValue');
            persistenceSlider.addEventListener('input', () => {
                persistenceValue.textContent = persistenceSlider.value;
            });
            persistenceSlider.addEventListener('change', updateSettings);
        });
    </script>
</body>
</html>