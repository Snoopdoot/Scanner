<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WiFi Network Scanner</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow: hidden;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .title {
            font-size: 24px;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 12px;
            opacity: 0.8;
        }

        select, button {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:hover, button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        button {
            background: #4CAF50;
        }

        button:hover {
            background: #45a049;
        }

        button.stop {
            background: #f44336;
        }

        button.stop:hover {
            background: #da190b;
        }

        .status {
            font-size: 14px;
            opacity: 0.8;
        }

        .stats {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            z-index: 999;
            min-width: 200px;
        }

        .stats h3 {
            margin-bottom: 10px;
            font-size: 16px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .network-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node:hover {
            stroke-width: 3px;
        }

        .node.ap {
            fill: #ff6b6b;
            stroke: #ff5252;
        }

        .node.client {
            fill: #4ecdc4;
            stroke: #26a69a;
        }

        .link {
            stroke-linecap: round;
            transition: all 0.3s ease;
        }

        .link:hover {
            stroke-width: 4px;
        }

        .arrow {
            fill: #ffffff;
            opacity: 0.7;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1001;
            max-width: 250px;
            backdrop-filter: blur(10px);
        }

        .legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            z-index: 999;
        }

        .legend h3 {
            margin-bottom: 10px;
            font-size: 16px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 1002;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">WiFi Network Scanner</div>
        <div class="controls">
            <div class="control-group">
                <label>WiFi Interface</label>
                <select id="interfaceSelect">
                    <option value="">Select Interface</option>
                </select>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="startBtn">Start Scan</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="stopBtn" class="stop" style="display: none;">Stop Scan</button>
            </div>
        </div>
        <div class="status" id="status">Ready</div>
    </div>

    <div class="stats">
        <h3>Network Statistics</h3>
        <div class="stat-item">
            <span>Access Points:</span>
            <span id="apCount">0</span>
        </div>
        <div class="stat-item">
            <span>Clients:</span>
            <span id="clientCount">0</span>
        </div>
        <div class="stat-item">
            <span>Connections:</span>
            <span id="connectionCount">0</span>
        </div>
        <div class="stat-item">
            <span>Total Packets:</span>
            <span id="packetCount">0</span>
        </div>
    </div>

    <div class="legend">
        <h3>Legend</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6b6b;"></div>
            <span>Access Points</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #4ecdc4;"></div>
            <span>Clients</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffffff;"></div>
            <span>Connections (thickness = traffic)</span>
        </div>
    </div>

    <svg class="network-canvas" id="networkCanvas"></svg>
    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <div class="loading" id="loading" style="display: none;">
        <div class="spinner"></div>
        <div>Starting WiFi scan...</div>
    </div>

    <script>
        // Global variables
        let socket;
        let simulation;
        let nodes = [];
        let links = [];
        let nodeMap = new Map();
        let linkMap = new Map();
        let isScanning = false;

        // D3 setup
        const width = window.innerWidth;
        const height = window.innerHeight;
        const svg = d3.select('#networkCanvas')
            .attr('width', width)
            .attr('height', height);

        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on('zoom', (event) => {
                svg.selectAll('g').attr('transform', event.transform);
            });

        svg.call(zoom);

        // Create main group for network elements
        const g = svg.append('g');

        // Arrow marker for directed edges
        svg.append('defs').append('marker')
            .attr('id', 'arrowhead')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 15)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('class', 'arrow');

        // Force simulation
        function createSimulation() {
            simulation = d3.forceSimulation()
                .force('link', d3.forceLink().id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));
        }

        // Initialize
        function init() {
            createSimulation();
            loadInterfaces();
            connectWebSocket();
            
            // Add test data to verify D3 is working
            setTimeout(() => {
                console.log('Adding test data to verify D3 visualization...');
                const testData = {
                    access_points: [
                        {
                            bssid: '00:11:22:33:44:55',
                            ssid: 'Test AP',
                            channel: 6,
                            signal_strength: -50,
                            packet_count: 10,
                            last_seen: new Date().toISOString()
                        }
                    ],
                    clients: [
                        {
                            mac: 'aa:bb:cc:dd:ee:ff',
                            packet_count: 5,
                            last_seen: new Date().toISOString()
                        }
                    ],
                    connections: [
                        {
                            ap_bssid: '00:11:22:33:44:55',
                            client_mac: 'aa:bb:cc:dd:ee:ff',
                            packet_count: 15,
                            thickness: 3,
                            direction: 'bidirectional'
                        }
                    ]
                };
                updateNetwork(testData);
            }, 3000);
        }

        // Load available WiFi interfaces
        async function loadInterfaces() {
            try {
                const response = await fetch('/api/interfaces');
                const data = await response.json();
                console.log('Interfaces data:', data);
                
                const select = document.getElementById('interfaceSelect');
                select.innerHTML = '<option value="">Select Interface</option>';
                
                if (data.interfaces && data.interfaces.length > 0) {
                    data.interfaces.forEach(iface => {
                        const option = document.createElement('option');
                        option.value = iface;
                        option.textContent = iface;
                        select.appendChild(option);
                        console.log('Added interface option:', iface);
                    });
                } else {
                    console.log('No interfaces found');
                    updateStatus('No WiFi interfaces detected');
                }
            } catch (error) {
                console.error('Error loading interfaces:', error);
                updateStatus('Error loading interfaces');
            }
        }

        // WebSocket connection
        function connectWebSocket() {
            socket = io();
            
            socket.on('connect', () => {
                updateStatus('Connected to scanner');
            });
            
            socket.on('disconnect', () => {
                updateStatus('Disconnected from scanner');
            });
            
                    socket.on('network_update', (data) => {
            console.log('Received network update:', data);
            updateNetwork(data);
        });
            
            socket.on('status', (data) => {
                updateStatus(data.message);
            });
        }

        // Start scanning
        async function startScan() {
            const selectedInterface = document.getElementById('interfaceSelect').value;
            console.log('Selected interface:', selectedInterface);
            
            if (!selectedInterface) {
                alert('Please select a WiFi interface');
                return;
            }

            showLoading(true);
            
            try {
                const requestData = { interface: selectedInterface };
                console.log('Sending start scan request:', requestData);
                
                const response = await fetch('/api/start_scan', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    isScanning = true;
                    updateStatus(data.message);
                    document.getElementById('startBtn').style.display = 'none';
                    document.getElementById('stopBtn').style.display = 'block';
                } else {
                    alert(data.error);
                }
            } catch (error) {
                console.error('Error starting scan:', error);
                alert('Error starting scan');
            } finally {
                showLoading(false);
            }
        }

        // Stop scanning
        async function stopScan() {
            try {
                const response = await fetch('/api/stop_scan', {
                    method: 'POST'
                });
                
                const data = await response.json();
                isScanning = false;
                updateStatus(data.message);
                document.getElementById('startBtn').style.display = 'block';
                document.getElementById('stopBtn').style.display = 'none';
            } catch (error) {
                console.error('Error stopping scan:', error);
            }
        }

        // Update network visualization
        function updateNetwork(data) {
            console.log('Updating network visualization with data:', data);
            
            // Update statistics
            document.getElementById('apCount').textContent = data.access_points.length;
            document.getElementById('clientCount').textContent = data.clients.length;
            document.getElementById('connectionCount').textContent = data.connections.length;
            
            let totalPackets = 0;
            data.connections.forEach(conn => {
                totalPackets += conn.packet_count;
            });
            document.getElementById('packetCount').textContent = totalPackets;

            // Create nodes from access points and clients
            const newNodes = [];
            
            // Add access points
            data.access_points.forEach(ap => {
                const node = {
                    id: ap.bssid,
                    type: 'ap',
                    label: ap.ssid || 'Unknown SSID',
                    bssid: ap.bssid,
                    channel: ap.channel,
                    signal: ap.signal_strength,
                    packet_count: ap.packet_count,
                    last_seen: ap.last_seen
                };
                newNodes.push(node);
                console.log('Added AP node:', node);
            });
            
            // Add clients
            data.clients.forEach(client => {
                const node = {
                    id: client.mac,
                    type: 'client',
                    label: `Client ${client.mac.slice(-6)}`,
                    mac: client.mac,
                    packet_count: client.packet_count,
                    last_seen: client.last_seen
                };
                newNodes.push(node);
                console.log('Added client node:', node);
            });

            // Create links from connections
            const newLinks = data.connections.map(conn => {
                const link = {
                    source: conn.ap_bssid,
                    target: conn.client_mac,
                    packet_count: conn.packet_count,
                    thickness: conn.thickness,
                    direction: conn.direction
                };
                console.log('Added connection link:', link);
                return link;
            });

            // Update visualization
            updateVisualization(newNodes, newLinks);
        }

        // Update D3 visualization
        function updateVisualization(newNodes, newLinks) {
            console.log('Updating D3 visualization with:', newNodes.length, 'nodes and', newLinks.length, 'links');
            
            // Update node map
            nodeMap.clear();
            newNodes.forEach(node => nodeMap.set(node.id, node));
            
            // Update link map
            linkMap.clear();
            newLinks.forEach(link => {
                const key = `${link.source}-${link.target}`;
                linkMap.set(key, link);
            });

            // Update nodes
            const nodeElements = g.selectAll('.node')
                .data(newNodes, d => d.id);

            // Remove old nodes
            nodeElements.exit().remove();

            // Add new nodes
            const nodeEnter = nodeElements.enter()
                .append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            console.log('Created', nodeEnter.size(), 'new node elements');

            nodeEnter.append('circle')
                .attr('r', d => d.type === 'ap' ? 15 : 10)
                .attr('class', d => `node ${d.type}`);

            nodeEnter.append('text')
                .attr('dy', '.35em')
                .attr('text-anchor', 'middle')
                .style('font-size', '10px')
                .style('fill', 'white')
                .style('pointer-events', 'none')
                .text(d => d.type === 'ap' ? d.label.substring(0, 8) : d.label);

            // Update existing nodes
            nodeElements.select('circle')
                .attr('r', d => d.type === 'ap' ? 15 : 10)
                .attr('class', d => `node ${d.type}`);

            // Update links
            const linkElements = g.selectAll('.link')
                .data(newLinks, d => `${d.source}-${d.target}`);

            // Remove old links
            linkElements.exit().remove();

            // Add new links
            const linkEnter = linkElements.enter()
                .append('line')
                .attr('class', 'link')
                .style('stroke', '#ffffff')
                .style('stroke-width', d => d.thickness)
                .style('opacity', 0.7);
            
            console.log('Created', linkEnter.size(), 'new link elements');

            // Add arrow if bidirectional
            linkEnter.filter(d => d.direction === 'bidirectional')
                .attr('marker-end', 'url(#arrowhead)');

            // Update existing links
            linkElements
                .style('stroke-width', d => d.thickness);

            // Update simulation
            console.log('Updating D3 simulation...');
            simulation.nodes(newNodes);
            simulation.force('link').links(newLinks);
            simulation.alpha(1).restart();
            console.log('D3 simulation restarted');

            // Store current data
            nodes = newNodes;
            links = newLinks;
        }

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Tooltip functions
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            let content = '';
            
            if (d.type === 'ap') {
                content = `
                    <strong>Access Point</strong><br>
                    SSID: ${d.label}<br>
                    BSSID: ${d.bssid}<br>
                    Channel: ${d.channel}<br>
                    Signal: ${d.signal} dBm<br>
                    Packets: ${d.packet_count}
                `;
            } else {
                content = `
                    <strong>Client</strong><br>
                    MAC: ${d.mac}<br>
                    Packets: ${d.packet_count}
                `;
            }
            
            tooltip.innerHTML = content;
            tooltip.style.display = 'block';
            tooltip.style.left = event.pageX + 10 + 'px';
            tooltip.style.top = event.pageY - 10 + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        // Utility functions
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', startScan);
        document.getElementById('stopBtn').addEventListener('click', stopScan);

        // Add tooltip events to nodes
        g.on('mouseover', '.node', showTooltip)
          .on('mouseout', '.node', hideTooltip);

        // Handle window resize
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            svg.attr('width', width).attr('height', height);
            simulation.force('center', d3.forceCenter(width / 2, height / 2));
            simulation.alpha(1).restart();
        });

        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
